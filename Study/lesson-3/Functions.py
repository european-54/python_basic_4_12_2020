"""
Функции дают возможность следовать принципу DRY(сухой, не повторяй себя).
А это значит, если у нас есть какой-то кусок кода, который повторяется в программе неоднократно, надо
это сжать до функции.Как же мы объявляем функцию - используем ключевое слово def(определить имя).
Задача:
Необходимо напечатать на экране YES, NO, если переданное число(ЦЕЛОЕ) имеет 3 цифры.Делением на 100 проверяем
сколько сотен в числе.
"""
def is_some(number: int, count: int)-> bool:
    """
    Документация первой строкой пишется, создаётся комментарий.Функция возвращает является ли число n разрядным
    :param number: int: число
    :param count: штеЖ количество цифр в числе
    :return: bool
    """
    return 1 <= (number // 10 ** (count -1)) < 10   #   идёт возврат значения, оно высчитывается и возвращается
#  Магия от Питона. Представим,что есть переменная, кот. явл. словарём
a = {
    'count': 5,
    'number': 23456,
}
b = [23456, 5] #  b = [23456, 5, 1] А вот так уже не будет работать, так как ф=ия ожидала 2-а аргумента, а мы передали
#  ей 3-и аргумента
b = (23456, 5) #  Не только список, ещё и кортеж
b = {23456, 5} #  Для set другая проблема он не гарантирует сохранение последовательности. Поэтому, при одном запуске
# будет всё работать, при другом нет
c = dict(count=3, number=3) #  Так получится
print(is_some(*b))

#  print(is_some(a))  Что делать,чтоб данные правильно ушли внутрь функции? При этой записи не получится. Можно так:
#  print(is_some(a['number'], a['count'])) А вот магия: print(is_some(**a)) При ** порядок не имеет значения.Эти **
#  символы для словарей.

a: bool = is_some(123.3) #  bool это указание аннотации типов.Аннотации помогают увидеть не ошиблись ли вы где-то.Анота
#  ции не обязательны.Анотация-это то, что вы ожидаете, но не обязательно то, что к вам пришло. Это правила хорошего
#  тона.Когда делаешь анотацию, а пользователь туда передал что-то другое, то это уже его проблемы.
b = is_some(123.4)
c = is_some(12.5)
d = is_some(123456.6)

print(any((a, b, c, d))) #  А как проверить хотя бы один из них any.

#  Проверим, что значения функции являются True или False. Для этого есть All. All ознаает, что все объекты,
#  внутри переданного интерированного объекта должны быть истиной.
    #  как нам понять, что число состоит из 3-х цифр(у числа нет len)
    #  В консоли определяем:a = 123
    # a // 100 > 0
    # True
    # a = 1234
    # a // 100 > 0
    # True
    # 1 <= (a // 100) < 10
    # False
    # a = 123
    # 1 <= (a // 100) < 10
    # True

"""
Ключевое слово def определяет функцию.Далее указывается имя функции по тем же правилам,что и имя переменной.
Далее в круглых скобках, может быть, а может и не быть, мы указываем аргументы, которые может принимать функция.
Аргументов может не быть, можно указать пустые скобки.Оаределение заканчивается двоеточием. После двоеточия мы указыва-
ем тело нашей функции. Данная функция у нас реализует определённую логику, она ничего не возвращает, то есть никакого
результата действий она не возвращает.Print это не результат работы функции, это её работа, её тело, то есть то,что
она вернула.Далее идёт то, каким образом мы можем её применять(some). Данная функция не совсем красивая, есть функции
 которые начинаются с is_. Далее у нас будет передаваться число и count(количество знаков которых оно принадлежит).
 Функция, которая начинается со знака is должна проверять.Данных, которые должна вернуть функция будет булевое.
 Мы после двоеточия указываем тип данных, которые принимает. Int можно не указывать, но лучше всё-же указывать, так как
 тогда при наведении курсора будет появляться окно, в котором видно, что это функция. При наведении на int будет ука-
 зываться, что будет возвращать функция. В данном случае, булевое.Ключевое слово return возвращает некий результат за 
 пределы нашей функции. То, что возвращает функция может быть присвоено переменной.В Python есть автодокументация, 
 нужно лишь навести курсор на функцию.
"""
#  Можно сделать и так:
print(is_some.__doc__)

#  и так:
print(int.__doc__)

#  или:
print(list.__doc__)

#  Поговорим о том, что такое позиционная передача данных и именованная передача данных.
print(is_some(234.2)) #  Передаю данные позиционно, последовательность важна!
print(is_some(count=2, number=5)) #  Передача именованная, последовательность не важна!
print(is_some(number=5, count=2)) #  В этом случае можно и так записать
#  При передаче аргументов(number=5) пробел между операторами не ставится, именно когда именованно

map() #  Ф-ия map принимает 2-а аргумента. Сначала она принимает функцию, а затем итерируемый объект(список, словарь,
# кортеж). Создадим список а:
a = [1, 2, 3, 4, 5]
#  Теперь хотим получить список строк на основе map
b = list(map(str, a))
# >>>a = [1, 2, 3, 4, 5]
# >>>b = list(map(str, a))
# >>>b
# ['1', '2', '3', '4', '5'] Вот что получаем, такой же список только состоящий из строк.То есть map применил ф-ию к
# каждому элементу
"""
Правило для дамашнего задания: чтобы пользоваться встроенными ф-ми, коих очень много, необходимо их написать.Ф-ии:
zip,            зип
map,            карта, 
reduce,         сокращения, 
filter,         фильтр, 
enumerate,      перечислять, 
range,          диапазон,
sum,            сумма,
min,            мин,
max.            Макс.

Сегодня используем одну свою ф-ию, остальные разберём по свойствам.
 """
def my_map(funk, iter_obj): #  Создаём свою ф-ию.Что о ней знаем, что берётся некая ф-ия и объект, то есть некий
# итерируемый объект.Что делает данная ф-ия:
    result = []
    for item in iter_obj:
        result.append(funk(item)) #  Чего не хватает ещё:
    return result
#  Теперь проверим в консоли работает ли она:
def my_map(funk, iter_obj):
    for item in iter_obj:
        yield funk(item)
#  Есть ф-ия next(а) кот. принимает в себя объект-генератор, либо объект-литератор и запрашивает следующее значение
a = my_map(str, [1, 2, 3, 4, 5]) #  Когда вызвали ф-ию, к нам вернулся генератор(так это работает). Когда вызвали next
# он вызвался до ближайшего yield, выдал результат и курсор остановился.Когда вызвали следующий next урсор продолжил
# свою работу с того места, где он остановился.И снова дошёл до yield выдал нам результат и т. д.Это говорит о том, что
# в ф-ии-генераторе может быть несколько yield.Но при этом, у нас не создаётся доп.объект.Он не захламляет нам память.
# Это можно делать и при помощи for и при next.Это даёт преимущества: экономия памяти и времени.
"""
Вывод: когда нам нужно обойти какую-то последовательность с действием, генераторы дают возможность получить 
промежуточные результаты и начать с ними работать,экономичнее расходовать оперативную память, потому что не 
плодить новых объектов.
"""
#  Ф-ию print(1, 2, 3, 4, 5, 6, 7) можно передавать напрямую значения, кот. будут напечатаны. Таким образом
#  бесконечную последовательность мы сделать не можем. Для этого используем:
def my_sum(*nums):
    print(type(nums)) #  nums относится к типу tuple. Это значит можно передавать неопределенное кол-во аргументов.
    # При такой записи мы работаем, как с обычным кортежем.
def my_sum(*args, factor=1):  # можно записать и так: def my_sum(*nums)
    print('factor', factor)
    print(args)
    result = 0
    for n in args:
        result += n
    return result * factor #  factor- множитель

print(my_sum(1, 2, 3, 4, 5, 6, 7, 10, 123, factor=2))

def my_sum(*args, **kwargs):  # kwargs -словарь
    print('kwargs', kwargs)
    print(args)
    result = 0
    for n in args:
        result += n
    return result * factor


print (type(a))
#  Все переменные-это объекты.Все определения идут через объекты
"""
Задача.
Необходимо сделать список квадрата чисел целых в диапазоне чисел от 1 до 10.Польз-ль будет вводить от а до
 в(включительно) и должен будет появиться
список с.
"""

a = 1
b = 10

c = []
#  Пробуем в консоли подобрать ф-ию

for n in range(a, b+1): #  Потому что range не включает последнее значение
    c.append(n**2)
print(c)
#  А теперь сделаем в одну строчку:
d = [n**2 for n in range(a, b+1)]
print(d) #  Генератор списка- это ф-ия с yield после кот. формируется список(Часто спрашивают на тестировании
# в англо-язычных компаниях). А это: [n**2 for n in range(a, b+1)] -> списковое выражение.Это совершенно обычный
# цикл запертый в анотацию типа, который по этому циклу складывает n**2 как содержимое, а переменную он
# берёт for n in range(a, b+1 отсюда.

#  Теперь немного комбинаторий. Представим, что есть 2-а списка:
nums_a = [1, 2, 3, 4, 5]
nums_b = [100, 200, 300, 400, 500]
#  Как сделать список, состоящий из кортежей, следующего содержания:
#  [(1, 100), (1, 200), (1, 300)]

nums_combinations = [(n_a, n_b) for n_a in nums_a for n_b in nums_b]

print(nums_combinations) # Это сработало с помощью вложенного цикла. То есть, аналогом написать было бы следующее:


result = []
for n_a in nums_a:
    for n_b in nums_b:
        result.append((n_a, n_b)) #  Но, вместо этого было выражение сверху в одну строку, кот. работает быстрее


#  А что, если я хочу получить от nums_a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
# nums_b = [100, 200, 300, 400, 500], список кортежей квадратов нечётных чисел.А получить я хочу словарь:
#  result = {1: 1**2, 2: 2**2}, где ключ 1 с результатом 1 ** 2 и т.д. Как это слелать:

nums_a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
nums_b = [100, 200, 300, 400, 500]

nums_result = {n: n ** 2 for n in nums_a}
print(nums_result) #  Так же можно делать set,tuple. Теперь сделаем, чтоб в квадрат возводились только нечётные:
# nums_result = {n: n ** 2 for n in nums_a if n & 1}. Добавлять в конце можно только один if(два уже нельзя).Для того,
# чтоб были наоборот чётные:  nums_result = {n: n ** 2 for n in nums_a if not n & 1}. А сейчас сделаем, чтоб у нас был
# tuple:  nums_result = tuple(n for n in nums_a if n & 1)

"""
Чистая ф-ия возвращает только определенный тип данных, либо совместимые типы.Т.е. она может вернуть int или float, 
float или str. Это плохо. Если в задаче написано про ф-ию, кот. что-то проверяет, то надо делать по логике is. Нужно 
помнить про изменяемые типы данных.Если передадим ф-ии список и она будет изменять его.Поэтому надо делать копию или 
не изменять, а создавать новый объект внутри ф-ии. Изменением занимаются методы в объектах, а не ф-ии.А ф-ии, крайне 
не желательно, чтоб они изменяли объекты за пределами себя. Есть функциональный стиль программирования об этом позже.
Ф-ия может вызывать сама себя, это рекурсивные ф-ии, что не очень хорошо и лучше избегать этого.У PYTHON есть 
ограничения на вложенность рекурсий, поэтому многое может пойти не так.Поэтому, если можно избавиться от рекурсии и 
делать на цикле, то надо делать на цикле. Иногда 2-е ф-ии можно объединить в одну, если они схожи по своим действиям.
Ф-ии позволяют разделить код на более мелкие,часто используемые блоки кода.Не стоит делать бесполезные ф-ии на все 
действия кода. У языка хаски нет ф-ий.Там всё- ф-ия.
"""


